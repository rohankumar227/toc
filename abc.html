<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
 <p> <pre>{

    "Tokenization Snippet": {
        "prefix": "tokenize_text",
        "body": [
            "my_text = \"\"\"Let's play a game, Would You Rather! It's simple, you have to pick one or the other.",
            "Let's get started. Would you rather try Vanilla Ice Cream or Chocolate one? Would you rather be a bird or a",
            "bat? Would you rather explore space or the ocean? Would you rather live on Mars or on the Moon? Would",
            "you rather have many good friends or one very best friend? Isn't it easy though? When we have fewer",
            "choices, it's easier to decide. But what if the options were complicated? I guess, you pretty much did not",
            "understand my point, neither did I, in the first place, and that led me to a decision.\"\"\"",
            "",
            "print(my_text.split())"
        ],
        "description": "A Python snippet for tokenizing text by splitting words."
    },
    "Regular Expression Snippet": {
        "prefix": "regex_search",
        "body": [
            "import re",
            "line = \"horses are taller than dog\"",
            "searchObj = re.search(r'(.*)are(.*)', line, re.M|re.I)",
            "if searchObj:",
            "    print(\"searchObj.group() :\", searchObj.group())",
            "    print(\"searchObj.group(1) :\", searchObj.group(1))",
            "    print(\"searchObj.group(2) :\", searchObj.group(2))",
            "else:",
            "    print(\"Nothing Found!!\")"
        ],
        "description": "A Python snippet for regular expression matching with re.search()."
    },
    "Derivation Sequence Snippet": {
        "prefix": "derivation_seq",
        "body": [
            "def printArray(arr, size):",
            "    for i in range(size):",
            "        print(arr[i], end=\" \")",
            "    print()",
            "    return",
            "",
            "def getSuccessor(arr, k, n):",
            "    p = k - 1",
            "    while (arr[p] == n and 0 <= p < k):",
            "        p -= 1",
            "    if (p < 0):",
            "        return 0",
            "    arr[p] = arr[p] + 1",
            "    i = p + 1",
            "    while(i < k):",
            "        arr[i] = 1",
            "        i += 1",
            "    return 1",
            "",
            "def printSequences(n, k):",
            "    arr = [0] * k",
            "    for i in range(k):",
            "        arr[i] = 1",
            "    while(1):",
            "        printArray(arr, k)",
            "        if(getSuccessor(arr, k, n) == 0):",
            "            break",
            "",
            "n = 3",
            "k = 2",
            "printSequences(n, k)"
        ],
        "description": "A Python snippet for generating derivation sequences/languages."
    },
    "Three Consecutive Characters Snippet": {
        "prefix": "three_consecutive",
        "body": [
            "def accepts_three_consecutive_ones(input_string):",
            "    state = 0",
            "    for char in input_string:",
            "        if char == '1':",
            "            state += 1",
            "        else:",
            "            state = 0",
            "        if state == 3:",
            "            return True",
            "    return False",
            "",
            "print(accepts_three_consecutive_ones(\"111\"))",
            "print(accepts_three_consecutive_ones(\"1111\"))",
            "print(accepts_three_consecutive_ones(\"10101\"))",
            "print(accepts_three_consecutive_ones(\"000\"))",
            "",
            "def accepts_three_consecutive_as(input_string):",
            "    state = 0",
            "    for char in input_string:",
            "        if char == 'a':",
            "            state += 1",
            "        else:",
            "            state = 0",
            "        if state == 3:",
            "            return True",
            "    return False",
            "",
            "print(accepts_three_consecutive_as(\"aaa\"))",
            "print(accepts_three_consecutive_as(\"aaaa\"))",
            "print(accepts_three_consecutive_as(\"aabaaa\"))",
            "print(accepts_three_consecutive_as(\"abc\"))",
            "",
            "def accepts_three_consecutive_bs(input_string):",
            "    state = 0",
            "    for char in input_string:",
            "        if char == 'b':",
            "            state += 1",
            "        else:",
            "            state = 0",
            "        if state == 3:",
            "            return True",
            "    return False",
            "",
            "print(accepts_three_consecutive_bs(\"bbb\"))",
            "print(accepts_three_consecutive_bs(\"bbbb\"))",
            "print(accepts_three_consecutive_bs(\"bbabbb\"))",
            "print(accepts_three_consecutive_bs(\"abc\"))",
            "",
            "def accepts_three_consecutive_zeros(input_string):",
            "    state = 0",
            "    for char in input_string:",
            "        if char == '0':",
            "            state += 1",
            "        else:",
            "            state = 0",
            "        if state == 3:",
            "            return True",
            "    return False",
            "",
            "print(accepts_three_consecutive_zeros(\"000\"))",
            "print(accepts_three_consecutive_zeros(\"0000\"))",
            "print(accepts_three_consecutive_zeros(\"100001\"))",
            "print(accepts_three_consecutive_zeros(\"111\"))"
        ],
        "description": "A snippet for checking three consecutive characters in an input string."
    },
    "FSM ending with 101": {
        "prefix": "fsm_101",
        "body": [
            "class FSM:",
            "    def __init__(self):",
            "        self.state = 0",
            "    def transition(self, char):",
            "        if self.state == 0:",
            "            if char == '1':",
            "                self.state = 1",
            "        elif self.state == 1:",
            "            if char == '0':",
            "                self.state = 2",
            "            elif char == '1':",
            "                self.state = 1",
            "        elif self.state == 2:",
            "            if char == '1':",
            "                self.state = 3",
            "            else:",
            "                self.state = 0",
            "        elif self.state == 3:",
            "            if char == '1':",
            "                self.state = 1",
            "            elif char == '0':",
            "                self.state = 2",
            "    def is_accepted(self, string):",
            "        self.state = 0",
            "        for char in string:",
            "            self.transition(char)",
            "        return self.state == 3",
            "fsm = FSM()",
            "test_strings = ['101', '1101', '000101', '1111101', '100', '10101']",
            "for s in test_strings:",
            "    print(f'String: {s}, Accepted: {fsm.is_accepted(s)}')"
        ],
        "description": "FSM that accepts strings ending with 101"
    },
    "FSM ending with aba": {
        "prefix": "fsm_aba",
        "body": [
            "class FSM:",
            "    def __init__(self):",
            "        self.state = 0",
            "    def transition(self, char):",
            "        if self.state == 0:",
            "            if char == 'a':",
            "                self.state = 1",
            "        elif self.state == 1:",
            "            if char == 'b':",
            "                self.state = 2",
            "            elif char == 'a':",
            "                self.state = 1",
            "        elif self.state == 2:",
            "            if char == 'a':",
            "                self.state = 3",
            "            else:",
            "                self.state = 0",
            "        elif self.state == 3:",
            "            if char == 'a':",
            "                self.state = 1",
            "            elif char == 'b':",
            "                self.state = 2",
            "    def is_accepted(self, string):",
            "        self.state = 0",
            "        for char in string:",
            "            self.transition(char)",
            "        return self.state == 3",
            "fsm = FSM()",
            "test_strings = ['aba', 'aaba', 'bababa', 'aaaba', 'abba', 'abaaba']",
            "for s in test_strings:",
            "    print(f'String: {s}, Accepted: {fsm.is_accepted(s)}')"
        ],
        "description": "FSM that accepts strings ending with aba"
    },
    "FSM ending with 100": {
        "prefix": "fsm_100",
        "body": [
            "class FSM:",
            "    def __init__(self):",
            "        self.state = 0",
            "    def transition(self, char):",
            "        if self.state == 0:",
            "            if char == '1':",
            "                self.state = 1",
            "        elif self.state == 1:",
            "            if char == '0':",
            "                self.state = 2",
            "            elif char == '1':",
            "                self.state = 1",
            "        elif self.state == 2:",
            "            if char == '0':",
            "                self.state = 3",
            "            elif char == '1':",
            "                self.state = 1",
            "        elif self.state == 3:",
            "            if char == '1':",
            "                self.state = 1",
            "            elif char == '0':",
            "                self.state = 2",
            "    def is_accepted(self, string):",
            "        self.state = 0",
            "        for char in string:",
            "            self.transition(char)",
            "        return self.state == 3",
            "fsm = FSM()",
            "test_strings = ['100', '1100', '000100', '1111100', '101', '100100']",
            "for s in test_strings:",
            "    print(f'String: {s}, Accepted: {fsm.is_accepted(s)}')"
        ],
        "description": "FSM that accepts strings ending with 100"
    },
    "FSM ending with aab": {
        "prefix": "fsm_aab",
        "body": [
            "class FSM:",
            "    def __init__(self):",
            "        self.state = 0",
            "    def transition(self, char):",
            "        if self.state == 0:",
            "            if char == 'a':",
            "                self.state = 1",
            "        elif self.state == 1:",
            "            if char == 'a':",
            "                self.state = 2",
            "            elif char == 'b':",
            "                self.state = 0",
            "        elif self.state == 2:",
            "            if char == 'b':",
            "                self.state = 3",
            "            elif char == 'a':",
            "                self.state = 2",
            "            else:",
            "                self.state = 0",
            "        elif self.state == 3:",
            "            if char == 'a':",
            "                self.state = 1",
            "            elif char == 'b':",
            "                self.state = 0",
            "    def is_accepted(self, string):",
            "        self.state = 0",
            "        for char in string:",
            "            self.transition(char)",
            "        return self.state == 3",
            "fsm = FSM()",
            "test_strings = ['aab', 'aaab', 'baab', 'aaaab', 'ab', 'aabaab']",
            "for s in test_strings:",
            "    print(f'String: {s}, Accepted: {fsm.is_accepted(s)}')"
        ],
        "description": "FSM that accepts strings ending with aab"
    },
      "Divisible by 2": {
          "prefix": "div_by_2",
          "body": [
              "def is_divisible_by_2(number: float) -> bool:",
              "    return number % 2 == 0",
              "",
              "while True:",
              "    try:",
              "        num = float(input(\"Enter a decimal number: \"))",
              "        if is_divisible_by_2(num):",
              "            print(f'{num} is divisible by 2.')",
              "            break",
              "        else:",
              "            print(f'{num} is not divisible by 2. Please try again.')",
              "    except ValueError:",
              "        print(\"Invalid input. Please enter a valid decimal number.\")"
          ],
          "description": "Check if a decimal number is divisible by 2."
      },
      "Divisible by 3": {
          "prefix": "div_by_3",
          "body": [
              "def is_divisible_by_3(number: float) -> bool:",
              "    return number % 3 == 0",
              "",
              "while True:",
              "    try:",
              "        num = float(input(\"Enter a decimal number: \"))",
              "        if is_divisible_by_3(num):",
              "            print(f'{num} is divisible by 3.')",
              "            break",
              "        else:",
              "            print(f'{num} is not divisible by 3. Please try again.')",
              "    except ValueError:",
              "        print(\"Invalid input. Please enter a valid decimal number.\")"
          ],
          "description": "Check if a decimal number is divisible by 3."
      },
      "Divisible by 4": {
          "prefix": "div_by_4",
          "body": [
              "def is_divisible_by_4(number: float) -> bool:",
              "    return number % 4 == 0",
              "",
              "while True:",
              "    try:",
              "        num = float(input(\"Enter a decimal number: \"))",
              "        if is_divisible_by_4(num):",
              "            print(f'{num} is divisible by 4.')",
              "            break",
              "        else:",
              "            print(f'{num} is not divisible by 4. Please try again.')",
              "    except ValueError:",
              "        print(\"Invalid input. Please enter a valid decimal number.\")"
          ],
          "description": "Check if a decimal number is divisible by 4."
      },
      "Divisible by 5": {
          "prefix": "div_by_5",
          "body": [
              "def is_divisible_by_5(number: float) -> bool:",
              "    return number % 5 == 0",
              "",
              "while True:",
              "    try:",
              "        num = float(input(\"Enter a decimal number: \"))",
              "        if is_divisible_by_5(num):",
              "            print(f'{num} is divisible by 5.')",
              "            break",
              "        else:",
              "            print(f'{num} is not divisible by 5. Please try again.')",
              "    except ValueError:",
              "        print(\"Invalid input. Please enter a valid decimal number.\")"
          ],
          "description": "Check if a decimal number is divisible by 5."
      },
      
    "Equal 1s and 0s": {
      "prefix": "equal_1s_0s",
      "body": [
          "def is_equal_ones_zeros(string):",
          "    count = 0",
          "    for char in string:",
          "        if char == '1':",
          "            count += 1",
          "        elif char == '0':",
          "            count -= 1",
          "        else:",
          "            return False",
          "    return count == 0",
          "",
          "test_cases = ['1100', '1010', '1001', '111000', '110011', '100101']",
          "for test in test_cases:",
          "    result = is_equal_ones_zeros(test)",
          "    print(f'String: {test}, Accepted: {result}')"
      ],
      "description": "Check if a string has equal number of 1s and 0s."
  },
  "Equal a's and b's": {
      "prefix": "equal_as_bs",
      "body": [
          "def is_equal_as_bs(string):",
          "    count = 0",
          "    for char in string:",
          "        if char == 'a':",
          "            count += 1",
          "        elif char == 'b':",
          "            count -= 1",
          "        else:",
          "            return False",
          "    return count == 0",
          "",
          "test_cases = ['abba', 'abab', 'aabb', 'aaabbb', 'ababab', 'aababb']",
          "for test in test_cases:",
          "    result = is_equal_as_bs(test)",
          "    print(f'String: {test}, Accepted: {result}')"
      ],
      "description": "Check if a string has equal number of a's and b's."
  },
    "Count Ones Zeros and A B": {
        "prefix": "countSymbols",
        "body": [
            "def count_ones_zeros(binary_string):",
            "    \"\"\"Count the number of 1's and 0's in the string.\"\"\"",
            "    ones_count = binary_string.count('1')",
            "    zeros_count = binary_string.count('0')",
            "    return ones_count, zeros_count",
            "",
            "# Example usage",
            "if __name__ == \"__main__\":",
            "    binary_string = input(\"Enter a binary string: \")",
            "    ones, zeros = count_ones_zeros(binary_string)",
            "    print(f\"Number of 1's: {ones}\")",
            "    print(f\"Number of 0's: {zeros}\")",
            "",
            "def count_as_bs(input_string):",
            "    \"\"\"Count the number of a's and b's in the string.\"\"\"",
            "    a_count = input_string.count('a')",
            "    b_count = input_string.count('b')",
            "    return a_count, b_count",
            "",
            "# Example usage",
            "if __name__ == \"__main__\":",
            "    input_string = input(\"Enter a string: \")",
            "    a_count, b_count = count_as_bs(input_string)",
            "    print(f\"Number of a's: {a_count}\")",
            "    print(f\"Number of b's: {b_count}\")"
        ],
        "description": "Counts the number of '1's and '0's in a binary string, and 'a's and 'b's in a given string."
    },
      "PDA WCWR": {
          "prefix": "pdaWCWR",
          "body": [
              "class PDA:",
              "    def __init__(self):",
              "        self.stack = []",
              "",
              "    def accept_wcwr(self, input_string):",
              "        n = len(input_string)",
              "        if n < 3 or 'C' not in input_string:",
              "            return False",
              "",
              "        c_index = input_string.index('C')",
              "        w = input_string[:c_index]",
              "        wR = input_string[c_index + 1:]",
              "",
              "        if wR[::-1] != w:",
              "            return False",
              "",
              "        for char in w:",
              "            self.stack.append(char)",
              "",
              "        if input_string[c_index] != 'C':",
              "            return False",
              "",
              "        for char in wR:",
              "            if not self.stack or self.stack.pop() != char:",
              "                return False",
              "",
              "        return len(self.stack) == 0",
              "",
              "# Example usage",
              "if __name__ == \"__main__\":",
              "    pda = PDA()",
              "    input_string = input(\"Enter a string: \")",
              "    if pda.accept_wcwr(input_string):",
              "        print(\"Accepted\")",
              "    else:",
              "        print(\"Rejected\")"
          ],
          "description": "Pushdown Automaton (PDA) to accept WCWR where W is any string, C is a special symbol, and WR is the reverse of W."
      },
    "turingMachine": {
          "prefix": "turingMachine",
          "body": [
              "def turingMachine(string):",
              "    string = list(string)",
              "    while 'B' in string:",
              "        string.remove('B')",
              "    ",
              "    n = len(string) // 3",
              "    if len(string) != 3 * n:",
              "        return f\"String {''.join(string)} is not Accepted!\"",
              "    ",
              "    if all(string[i] == 'a' for i in range(n)) and \\",
              "       all(string[i] == 'b' for i in range(n, 2 * n)) and \\",
              "       all(string[i] == 'c' for i in range(2 * n, 3 * n)):",
              "        return f\"String {''.join(string)} is Accepted!\"",
              "    else:",
              "        return f\"String {''.join(string)} is not Accepted!\"",
              "",
              "while True:",
              "    string = input(\"Enter a String: \")",
              "    print(turingMachine(string))"
          ],
          "description": "Turing Machine string validator"
      },
      
  
  }
  </pre></p>

</body>
</html>
